(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{547:function(_,t,a){"use strict";a.r(t);var v=a(2),r=Object(v.a)({},(function(){var _=this,t=_.$createElement,a=_._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h3",{attrs:{id:"redis缓存的三大问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis缓存的三大问题"}},[_._v("#")]),_._v(" Redis缓存的三大问题")]),_._v(" "),a("h3",{attrs:{id:"_1、缓存穿透"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、缓存穿透"}},[_._v("#")]),_._v(" 1、缓存穿透")]),_._v(" "),a("hr"),_._v(" "),a("h4",{attrs:{id:"_1-1、什么是缓存穿透"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1、什么是缓存穿透"}},[_._v("#")]),_._v(" 1.1、什么是缓存穿透")]),_._v(" "),a("hr"),_._v(" "),a("p",[_._v("缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起id为-1的数据或者特别大的不存在的数据。有可能是黑客利用漏洞攻击从而去压垮应用的数据库。")]),_._v(" "),a("h4",{attrs:{id:"_1-2、常见解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2、常见解决方案"}},[_._v("#")]),_._v(" 1.2、常见解决方案")]),_._v(" "),a("hr"),_._v(" "),a("p",[_._v("对于缓存穿透问题，常见的解决方案有以下三种：")]),_._v(" "),a("ul",[a("li",[_._v("验证拦截：接口层进行校验，如鉴定用户权限，对ID之类的字段做基础的校验，如"),a("code",[_._v("id<=0")]),_._v("的字段直接拦截；")]),_._v(" "),a("li",[_._v("缓存空数据：当数据库查询到的数据为空时，也将这条数据进行缓存，但缓存的有效性设置得要较短，以免影响正常数据的缓存；")]),_._v(" "),a("li",[_._v("使用布隆过滤器：布隆过滤器是一种比较独特数据结构，有一定的误差。当它指定一个数据存在时，它不一定存在，但是当它指定一个数据不存在时，那么它一定是不存在的。")])]),_._v(" "),a("h4",{attrs:{id:"_1-4、缓存空数据与布隆过滤器比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4、缓存空数据与布隆过滤器比较"}},[_._v("#")]),_._v(" 1.4、缓存空数据与布隆过滤器比较")]),_._v(" "),a("hr"),_._v(" "),a("p",[_._v("上面对这两种方案都进行了简单的介绍，缓存空数据与布隆过滤器都能有效解决缓存穿透问题，但使用场景有着些许不同；")]),_._v(" "),a("ul",[a("li",[_._v("当一些恶意攻击查询查询的key各不相同，而且数量巨多，此时缓存空数据不是一个好的解决方案。因为它需要存储所有的Key，内存空间占用高。并且在这种情况下，很多key可能只用一次，所以存储下来没有意义。所以对于这种情况而言，使用布隆过滤器是个不错的选择；")]),_._v(" "),a("li",[_._v("而对与空数据的Key数量有限、Key重复请求效率较高的场景而言，可以选择缓存空数据的方案。")])]),_._v(" "),a("h3",{attrs:{id:"_2、缓存击穿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、缓存击穿"}},[_._v("#")]),_._v(" 2、缓存击穿")]),_._v(" "),a("hr"),_._v(" "),a("h4",{attrs:{id:"_2-1、什么是缓存击穿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1、什么是缓存击穿"}},[_._v("#")]),_._v(" 2.1、什么是缓存击穿")]),_._v(" "),a("hr"),_._v(" "),a("p",[_._v("缓存击穿是指当前热点数据存储到期时，多个线程同时并发访问热点数据。因为缓存刚过期，所有并发请求都会到数据库中查询数据。")]),_._v(" "),a("h4",{attrs:{id:"_2-2、解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2、解决方案"}},[_._v("#")]),_._v(" 2.2、解决方案")]),_._v(" "),a("hr"),_._v(" "),a("ul",[a("li",[_._v("将热点数据设置为永不过期；")]),_._v(" "),a("li",[_._v("加互斥锁：互斥锁可以控制查询数据库的线程访问，但这种方案会导致系统的吞吐量下降，需要根据实际情况使用。")])]),_._v(" "),a("h3",{attrs:{id:"_3、缓存雪崩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、缓存雪崩"}},[_._v("#")]),_._v(" 3、缓存雪崩")]),_._v(" "),a("hr"),_._v(" "),a("h4",{attrs:{id:"_3-1、什么是缓存雪崩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1、什么是缓存雪崩"}},[_._v("#")]),_._v(" 3.1、什么是缓存雪崩")]),_._v(" "),a("hr"),_._v(" "),a("p",[_._v("缓存雪崩发生有几种情况，比如大量缓存集中在或者缓存同时在大范围中失效，出现了大量请求去访问数据库，从而导致CPU和内存过载，甚至停机。")]),_._v(" "),a("p",[_._v("一个简单的雪崩过程：")]),_._v(" "),a("ol",[a("li",[_._v("Redis 集群产生了大面积故障；")]),_._v(" "),a("li",[_._v("缓存失败，此时仍有大量请求去访问 Redis 缓存服务器；")]),_._v(" "),a("li",[_._v("在大量 Redis 请求失败后，这些请求将会去访问数据库；")]),_._v(" "),a("li",[_._v("由于应用的设计依赖于数据库和 Redis 服务，很快就会造成服务器集群的雪崩，最终导致整个系统的瘫痪。")])]),_._v(" "),a("h4",{attrs:{id:"_3-2、解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2、解决方案"}},[_._v("#")]),_._v(" 3.2、解决方案")]),_._v(" "),a("hr"),_._v(" "),a("ul",[a("li",[_._v("【事前】高可用缓存：高可用缓存是防止出现整个缓存故障。即使个别节点，机器甚至机房都关闭，系统仍然可以提供服务，Redis 哨兵(Sentinel) 和 Redis 集群(Cluster) 都可以做到高可用；")]),_._v(" "),a("li",[_._v("【事中】缓存降级（临时支持）：当访问次数急剧增加导致服务出现问题时，我们如何确保服务仍然可用。在国内使用比较多的是 Hystrix，它通过熔断、降级、限流三个手段来降低雪崩发生后的损失。只要确保数据库不死，系统总可以响应请求，每年的春节 12306 我们不都是这么过来的吗？只要还可以响应起码还有抢到票的机会；")]),_._v(" "),a("li",[_._v("【事后】Redis备份和快速预热：Redis数据备份和恢复、快速缓存预热。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);