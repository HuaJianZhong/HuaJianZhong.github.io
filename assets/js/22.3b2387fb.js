(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{546:function(e,t,_){"use strict";_.r(t);var a=_(2),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h3",{attrs:{id:"缓存的读写策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存的读写策略"}},[e._v("#")]),e._v(" 缓存的读写策略")]),e._v(" "),_("h3",{attrs:{id:"_1、cache-aside-旁路缓存-策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、cache-aside-旁路缓存-策略"}},[e._v("#")]),e._v(" 1、Cache Aside（旁路缓存）策略")]),e._v(" "),_("hr"),e._v(" "),_("p",[e._v("Cache Aside 策略（也叫旁路缓存策略），这个策略数据以数据库中的数据为准，缓存中的数据是按需加载的。  在更新数据时不更新缓存，而是删除缓存中的数据，在读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。  它可以分为读策略和写策略 。")]),e._v(" "),_("p",[_("strong",[e._v("读策略")])]),e._v(" "),_("p",[_("img",{attrs:{src:"/img/1610932722146.png",alt:""}})]),e._v(" "),_("ul",[_("li",[e._v("从缓存中读取数据")]),e._v(" "),_("li",[e._v("如果缓存命中，则直接返回数据")]),e._v(" "),_("li",[e._v("如果缓存不命中，则从数据库中查询数据")]),e._v(" "),_("li",[e._v("查询到数据后，将数据写入到缓存中，并且返回给用户")])]),e._v(" "),_("p",[_("strong",[e._v("写策略")])]),e._v(" "),_("p",[_("img",{attrs:{src:"/img/20210120105009.png",alt:""}})]),e._v(" "),_("ul",[_("li",[e._v("更新数据库中的记录")]),e._v(" "),_("li",[e._v("删除缓存记录")])]),e._v(" "),_("p",[_("strong",[e._v("疑问")])]),e._v(" "),_("p",[_("strong",[e._v("在写数据的过程中，可以先删除 cache ，后更新 DB 么？")])]),e._v(" "),_("hr"),e._v(" "),_("p",[_("strong",[e._v("答案：")]),e._v(" 那肯定是不行的！因为这样可能会造成数据库（DB）和缓存（Cache）数据不一致的问题。为什么呢？比如说请求1 先写数据A，请求2随后读数据A的话就很有可能产生数据不一致性的问题。这个过程可以简单描述为：")]),e._v(" "),_("blockquote",[_("p",[e._v("请求1先把cache中的A数据删除 -> 请求2从DB中读取数据->请求2将数据写入缓存->请求1再把DB中的A数据更新。")])]),e._v(" "),_("p",[_("strong",[e._v("在写数据的过程中，先更新DB，后删除cache就没有问题了么？")])]),e._v(" "),_("hr"),e._v(" "),_("p",[e._v("理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多！")]),e._v(" "),_("p",[e._v("比如请求1先读数据 A，请求2随后写数据A，并且数据A不在缓存中的话也有可能产生数据不一致性的问题。这个过程可以简单描述为：")]),e._v(" "),_("blockquote",[_("p",[e._v("请求1从DB读数据A->请求2写更新数据 A 到数据库并把删除cache中的A数据->请求1将数据A写入cache。")])]),e._v(" "),_("p",[e._v("如果更新DB再去删除缓存时，删除缓存失败，在下一个写操作前缓存的数据都是旧数据。")]),e._v(" "),_("p",[_("strong",[e._v("缺陷")])]),e._v(" "),_("p",[_("strong",[e._v("缺陷1：首次请求数据一定不在 cache 的问题")])]),e._v(" "),_("p",[e._v("解决办法：可以将热点数据可以提前放入cache 中。")]),e._v(" "),_("p",[_("strong",[e._v("缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。")])]),e._v(" "),_("p",[e._v("解决办法：")]),e._v(" "),_("ul",[_("li",[e._v("数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。")]),e._v(" "),_("li",[e._v("可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。")])]),e._v(" "),_("h3",{attrs:{id:"_2、read-write-through-pattern-读写穿透"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、read-write-through-pattern-读写穿透"}},[e._v("#")]),e._v(" 2、Read/Write Through Pattern（读写穿透）")]),e._v(" "),_("hr"),e._v(" "),_("p",[e._v("Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。")]),e._v(" "),_("p",[e._v("这种缓存读写策略在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入DB的功能。")]),e._v(" "),_("p",[_("strong",[e._v("写（Write Through）：")])]),e._v(" "),_("ul",[_("li",[e._v("先查 cache，cache 中不存在，直接更新 DB。")]),e._v(" "),_("li",[e._v("cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（"),_("strong",[e._v("同步更新 cache 和 DB")]),e._v("）。")])]),e._v(" "),_("p",[_("strong",[e._v("读(Read Through)：")])]),e._v(" "),_("ul",[_("li",[_("p",[e._v("从 cache 中读取数据，读取到就直接返回 。")])]),e._v(" "),_("li",[_("p",[e._v("读取不到的话，先从 DB 加载，写入到 cache 后返回响应。")])])]),e._v(" "),_("p",[e._v("Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。")]),e._v(" "),_("p",[e._v("和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。")]),e._v(" "),_("h3",{attrs:{id:"_3、write-behind-pattern-异步缓存写入"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、write-behind-pattern-异步缓存写入"}},[e._v("#")]),e._v(" 3、Write Behind Pattern（异步缓存写入）")]),e._v(" "),_("hr"),e._v(" "),_("p",[e._v("Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。")]),e._v(" "),_("p",[e._v("但是，两个又有很大的不同："),_("strong",[e._v("Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。")])]),e._v(" "),_("p",[e._v("很明显，这种方式对数据一致性带来了更大的挑战，比如cache数据可能还没异步更新DB的话，cache服务可能就就挂掉了。")]),e._v(" "),_("p",[e._v("这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 InnoDB Buffer Pool 机制都用到了这种策略。")]),e._v(" "),_("p",[e._v("Write Behind Pattern 下 DB 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。")])])}),[],!1,null,null,null);t.default=v.exports}}]);